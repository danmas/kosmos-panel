<!doctype html>
<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <title>Terminal</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="https://unpkg.com/xterm/css/xterm.css" />
    <script src="https://unpkg.com/xterm/lib/xterm.js"></script>
    <script src="https://unpkg.com/xterm-addon-fit/lib/xterm-addon-fit.js"></script>
    <style>
      html, body { height:100%; margin:0; background:#0b0f1a; color:#e6ecff; }
      .wrap { height:100%; display:flex; flex-direction:column; }
      .top { padding:8px 10px; background:#0e1322; border-bottom:1px solid #1c2333; display:flex; gap:8px; align-items:center; }
      .title { font-weight:700; }
      .term { flex:1; background:#000; }
      .bar { padding:6px 10px; background:#0e1322; border-top:1px solid #1c2333; display:flex; gap:8px; }
      button { background:#1b2544; border:1px solid #223055; color:#e6ecff; border-radius:8px; padding:6px 10px; cursor:pointer; }
      .term-container { position: relative; flex: 1; display: flex; }
      .term { flex: 1; background: #000; }
      .log-indicator {
        position: absolute;
        top: 10px;
        right: 10px;
        width: 24px;
        height: 24px;
        background: #1b2544;
        border: 1px solid #223055;
        border-radius: 50%;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        opacity: 0.7;
        transition: opacity 0.2s;
        z-index: 10;
      }
      .log-indicator:hover { opacity: 1; }
      
      /* Remote command confirmation panel */
      .command-confirm {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        background: linear-gradient(180deg, #1a2744 0%, #0e1322 100%);
        border-top: 2px solid #ffa500;
        padding: 12px 16px;
        z-index: 1001;
        display: flex;
        flex-direction: column;
        gap: 10px;
        box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.5);
        animation: slideUp 0.2s ease-out;
      }
      .command-confirm.hidden { display: none; }
      @keyframes slideUp {
        from { transform: translateY(100%); opacity: 0; }
        to { transform: translateY(0); opacity: 1; }
      }
      .command-confirm-header {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 12px;
        color: #ffa500;
        font-weight: 600;
      }
      .command-confirm-badge {
        background: #ffa500;
        color: #000;
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 10px;
        text-transform: uppercase;
      }
      .command-confirm-text {
        font-family: 'Courier New', monospace;
        background: #000;
        padding: 10px 12px;
        border-radius: 6px;
        border: 1px solid #333;
        color: #00ff00;
        font-size: 13px;
        word-break: break-all;
        max-height: 100px;
        overflow-y: auto;
      }
      .command-confirm-buttons {
        display: flex;
        gap: 10px;
        justify-content: flex-end;
      }
      .command-confirm-buttons button {
        padding: 8px 16px;
        font-size: 13px;
        font-weight: 600;
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.15s ease;
      }
      .btn-confirm {
        background: #22c55e;
        border: 1px solid #16a34a;
        color: #fff;
      }
      .btn-confirm:hover { background: #16a34a; }
      .btn-reject {
        background: #ef4444;
        border: 1px solid #dc2626;
        color: #fff;
      }
      .btn-reject:hover { background: #dc2626; }
      .btn-skip {
        background: #3b82f6;
        border: 1px solid #2563eb;
        color: #fff;
      }
      .btn-skip:hover { background: #2563eb; }
      
      /* Session ID indicator */
      .session-indicator {
        position: absolute;
        top: 8px;
        left: 10px;
        font-size: 11px;
        color: #4a9eff;
        font-family: monospace;
        background: rgba(0, 0, 0, 0.7);
        padding: 4px 8px;
        border-radius: 4px;
        border: 1px solid #223055;
        z-index: 10;
        user-select: all;
        cursor: pointer;
        transition: all 0.15s ease;
      }
      .session-indicator:hover { 
        background: rgba(74, 158, 255, 0.2);
        color: #fff;
      }
      #reconnect { 
        background: #22c55e; 
        border-color: #16a34a; 
      }
      #reconnect:hover { 
        background: #16a34a; 
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="top">
        <div class="title" id="t"></div>
        <button id="close">–ó–∞–∫—Ä—ã—Ç—å</button>
        <button id="fit">–ü–æ–¥–æ–≥–Ω–∞—Ç—å</button>
        <button id="reconnect" style="display:none;">–ü–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–∏—Ç—å</button>
      </div>
      <div class="term-container">
        <div id="term" class="term"></div>
        <div class="session-indicator" id="sessionIndicator" title="Session ID –¥–ª—è REST API"></div>
        <div class="log-indicator" id="logIndicator" title="–ü–æ–∫–∞–∑–∞—Ç—å –ª–æ–≥ –∫–æ–º–∞–Ω–¥—ã">üìã</div>
        
        <!-- Remote command confirmation panel -->
        <div id="commandConfirm" class="command-confirm hidden">
          <div class="command-confirm-header">
            <span class="command-confirm-badge">REST API</span>
            <span>–£–¥–∞–ª—ë–Ω–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞ —Ç—Ä–µ–±—É–µ—Ç –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è</span>
          </div>
          <div class="command-confirm-text" id="commandConfirmText"></div>
          <div class="command-confirm-buttons">
            <button class="btn-reject" id="confirmNo">–û—Ç–∫–ª–æ–Ω–∏—Ç—å</button>
            <button class="btn-skip" id="confirmSkip">–í—ã–ø–æ–ª–Ω–∏—Ç—å –±–µ–∑ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è</button>
            <button class="btn-confirm" id="confirmYes">–í—ã–ø–æ–ª–Ω–∏—Ç—å</button>
          </div>
        </div>
      </div>
    </div>
    <script>
      const params = new URLSearchParams(location.search);
      const mode = params.get('mode');
      const serverId = params.get('serverId');
      const path = params.get('path') || '';
      const title = document.getElementById('t');
      title.textContent = mode === 'tail' ? `tail ${path}` : `terminal (${serverId})`;
      const termDiv = document.getElementById('term');
      const term = new Terminal({ convertEol:true, cursorBlink:true, theme:{ background:'#000000', foreground:'#00ff00' } });
      
      const fit = new window.FitAddon.FitAddon();
      term.loadAddon(fit); term.open(termDiv); setTimeout(()=>{ try{fit.fit()}catch{} },0);
      const wsProto = location.protocol === 'https:' ? 'wss' : 'ws';
      const wsUrl = mode === 'tail'
        ? `${wsProto}://${location.host}/ws/tail?serverId=${encodeURIComponent(serverId)}&path=${encodeURIComponent(path)}&lines=200`
        : `${wsProto}://${location.host}/ws/terminal?serverId=${encodeURIComponent(serverId)}&cols=120&rows=30`;
      const ws = new WebSocket(wsUrl);
      term.writeln(mode === 'tail' ? `[tail ${path}]` : '[–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ SSH...]');
      ws.onopen = () => term.writeln('[—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ]');
      ws.onclose = ev => {
        console.warn('[ws] closed:', ev.code, ev.reason);
        term.writeln(`\r\n[—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∑–∞–∫—Ä—ã—Ç–æ –∫–æ–¥ ${ev.code}${ev.reason ? ' ' + ev.reason : ''}]`);
        document.getElementById('reconnect').style.display = 'inline-block';
      };
      ws.onerror = err => {
        console.error('[ws] error:', err);
        term.writeln(`\r\n[–æ—à–∏–±–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è]`);
      };

      // ========== REST Bridge Variables ==========
      let currentSessionId = null;
      let pendingRemoteCommand = null;
      let remoteCommandBuffer = '';
      let remoteCommandCollecting = false;
      const promptRegex = /\w+@[\w\-\.]+[^$#>]*[\$#>]\s*$/;

      // ========== WebSocket Message Handler ==========
      ws.onmessage = ev => {
        try {
          const m = JSON.parse(ev.data);
          
          // –û–±—Ä–∞–±–æ—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö —Ç–µ—Ä–º–∏–Ω–∞–ª–∞
          if (m.type === 'data' || m.type === 'err') {
            term.write(m.data);
            
            // –°–±–æ—Ä –≤—ã–≤–æ–¥–∞ –¥–ª—è remote –∫–æ–º–∞–Ω–¥—ã
            if (remoteCommandCollecting && pendingRemoteCommand) {
              remoteCommandBuffer += m.data;
              checkRemoteCommandCompletion();
            }
          }
          
          // Fatal error
          if (m.type === 'fatal') {
            term.writeln(`\r\n[FATAL] ${m.error}`);
          }
          
          // –ü–æ–ª—É—á–µ–Ω–∏–µ sessionId –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞
          if (m.type === 'session' && m.sessionId) {
            currentSessionId = m.sessionId;
            console.log('[REST Bridge] Session ID received:', currentSessionId);
            updateSessionIndicator();
          }
          
          // Remote command –æ—Ç REST API
          if (m.type === 'remote_command') {
            handleRemoteCommand(m);
          }
          
          // –û—Ç–º–µ–Ω–∞ –∫–æ–º–∞–Ω–¥—ã
          if (m.type === 'cancel_command' && m.commandId) {
            if (pendingRemoteCommand && pendingRemoteCommand.commandId === m.commandId) {
              console.log('[REST Bridge] Command cancelled:', m.commandId);
              hideCommandConfirm();
              pendingRemoteCommand = null;
              remoteCommandCollecting = false;
              remoteCommandBuffer = '';
            }
          }
        } catch (e) {
          console.error('[ws.onmessage] Error:', e);
        }
      };
      
      let aiCommandPrefix = 'ai:';

      fetch('/api/config')
        .then(res => res.json())
        .then(config => {
          if (config.aiCommandPrefix) {
            aiCommandPrefix = config.aiCommandPrefix;
          }
        })
        .catch(err => console.error('Failed to fetch AI config:', err));
        
      if (mode !== 'tail') {
        term.onData(d => { try { ws.send(JSON.stringify({ type:'data', data:d })); } catch {} });
        
        term.attachCustomKeyEventHandler((arg) => {
          if (arg.code === 'Enter' && arg.type === 'keydown') {
            const buffer = term.buffer.active;
            
            // –ò—â–µ–º –ø–æ—Å–ª–µ–¥–Ω—é—é —Å—Ç—Ä–æ–∫—É —Å shell prompt
            for (let i = buffer.length - 1; i >= 0; i--) {
              const line = buffer.getLine(i).translateToString(true);
              const promptEndIndex = Math.max(line.lastIndexOf('$'), line.lastIndexOf('#'), line.lastIndexOf('>'));

              if (promptEndIndex !== -1) {
                const commandPart = line.substring(promptEndIndex + 1).trim();
                
                // –£–±–∏—Ä–∞–µ–º ANSI –∫–æ–¥—ã –∏–∑ –∫–æ–º–∞–Ω–¥—ã
                const cleanCommand = commandPart.replace(/\x1b\[[0-9;?]*[a-zA-Z]/g, '').replace(/[\b\u0007]/g, '').trim();
                
                const prefixText = aiCommandPrefix.slice(0, -1);
                const prefixSep = aiCommandPrefix.slice(-1);
                const commandRegex = new RegExp(`(${prefixText}\\s*${prefixSep})`);
                
                const match = commandPart.match(commandRegex);

                if (match) {
                  // AI –∫–æ–º–∞–Ω–¥–∞
                  const aiPrompt = commandPart.substring(match.index + match[0].length).trim();
                  term.write('\r\n\x1b[1;33m–ó–∞–ø—Ä–æ—Å –∫ AI: ' + aiPrompt + '\x1b[0m\r\n');
                  
                  ws.send(JSON.stringify({ type: 'ai_query', prompt: line }));
                  return false; // –ë–ª–æ–∫–∏—Ä—É–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—É—é –æ—Ç–ø—Ä–∞–≤–∫—É Enter
                } else if (cleanCommand) {
                  // –û–±—ã—á–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞ - –ª–æ–≥–∏—Ä—É–µ–º –µ—ë
                  console.log(`[DEBUG] –õ–æ–≥–∏—Ä—É–µ–º –æ–±—ã—á–Ω—É—é –∫–æ–º–∞–Ω–¥—É: "${cleanCommand}"`);
                  ws.send(JSON.stringify({ type: 'command_log', command: cleanCommand }));
                }
                break; // –ù–∞—à–ª–∏ –ø—Ä–æ–º–ø—Ç, –≤—ã—Ö–æ–¥–∏–º
              }
            }
          }
          return true; // –†–∞–∑—Ä–µ—à–∞–µ–º –≤—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ –∫–ª–∞–≤–∏—à–∏
        });
      }

      document.getElementById('close').onclick = () => { try { ws.close(); } catch {}; window.close(); };
      document.getElementById('fit').onclick = () => { try { fit.fit(); } catch {} };
      document.getElementById('reconnect').onclick = () => {
        location.reload(); // –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å —Å—Ç—Ä–∞–Ω–∏—Ü—É –¥–ª—è –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è
      };

      // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–ª–∏–∫–∞ –Ω–∞ –∏–∫–æ–Ω–∫—É –ª–æ–≥–æ–≤ - –æ—Ç–∫—Ä—ã–≤–∞–µ—Ç –æ—Ç–¥–µ–ª—å–Ω–æ–µ –æ–∫–Ω–æ
      document.getElementById('logIndicator').onclick = () => {
        if (currentSessionId) {
          const logsUrl = `/logs.html?sessionId=${encodeURIComponent(currentSessionId)}`;
          window.open(logsUrl, 'terminal-logs', 'width=800,height=600');
        } else {
          term.writeln('\r\n\x1b[1;33m[INFO] Session ID –µ—â–µ –Ω–µ –ø–æ–ª—É—á–µ–Ω, –ø–æ–¥–æ–∂–¥–∏—Ç–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è\x1b[0m');
        }
      };

      // ========== REST Bridge Functions ==========
      
      function updateSessionIndicator() {
        const indicator = document.getElementById('sessionIndicator');
        if (indicator && currentSessionId) {
          indicator.textContent = `üîó Session: ${currentSessionId.substring(0, 8)}...`;
          indicator.title = `Session ID –¥–ª—è REST API:\n${currentSessionId}\n\n–ö–ª–∏–∫–Ω–∏—Ç–µ –¥–ª—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è`;
          indicator.style.display = 'block';
          indicator.onclick = () => {
            navigator.clipboard.writeText(currentSessionId).then(() => {
              const original = indicator.textContent;
              indicator.textContent = '‚úì –°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ!';
              indicator.style.background = 'rgba(34, 197, 94, 0.3)';
              setTimeout(() => {
                indicator.textContent = original;
                indicator.style.background = '';
              }, 1500);
            });
          };
          
          // –¢–∞–∫–∂–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –≤ —Ç–µ—Ä–º–∏–Ω–∞–ª–µ –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞
          term.writeln(`\x1b[90m[Session ID: ${currentSessionId}]\x1b[0m`);
        }
      }

      function handleRemoteCommand(msg) {
        console.log('[REST Bridge] Remote command received:', msg);
        
        // –í–∏–∑—É–∞–ª—å–Ω—ã–π –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –ø–æ–ª—É—á–µ–Ω–∏—è –∫–æ–º–∞–Ω–¥—ã
        term.writeln(`\r\n\x1b[1;45;97m ‚ö° REST API COMMAND ‚ö° \x1b[0m`);
        term.writeln(`\x1b[1;35mCommand ID:\x1b[0m ${msg.commandId}`);
        term.writeln(`\x1b[1;35mCommand:\x1b[0m \x1b[1;33m${msg.command}\x1b[0m`);
        term.writeln(`\x1b[1;35mConfirmation:\x1b[0m ${msg.requireConfirmation ? 'Required' : 'Not required'}`);
        
        pendingRemoteCommand = {
          commandId: msg.commandId,
          command: msg.command,
          requireConfirmation: msg.requireConfirmation
        };

        if (msg.requireConfirmation) {
          // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–∞–Ω–µ–ª—å –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è
          showCommandConfirm(msg.command);
        } else {
          // –í—ã–ø–æ–ª–Ω—è–µ–º —Å—Ä–∞–∑—É
          executeRemoteCommand(msg.command);
        }
      }

      function showCommandConfirm(command) {
        const panel = document.getElementById('commandConfirm');
        const textEl = document.getElementById('commandConfirmText');
        
        textEl.textContent = command;
        panel.classList.remove('hidden');
        
        // –í–∏–∑—É–∞–ª—å–Ω—ã–π –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –≤ —Ç–µ—Ä–º–∏–Ω–∞–ª–µ
        term.writeln('\r\n\x1b[1;33m[REST API] –û–∂–∏–¥–∞–µ—Ç—Å—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –∫–æ–º–∞–Ω–¥—ã...\x1b[0m');
      }

      function hideCommandConfirm() {
        const panel = document.getElementById('commandConfirm');
        panel.classList.add('hidden');
      }

      function executeRemoteCommand(command) {
        console.log('[REST Bridge] Executing command:', command);
        
        // –ù–∞—á–∏–Ω–∞–µ–º —Å–±–æ—Ä –≤—ã–≤–æ–¥–∞
        remoteCommandBuffer = '';
        remoteCommandCollecting = true;
        
        // –í–∏–∑—É–∞–ª—å–Ω—ã–π –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä
        term.writeln(`\r\n\x1b[1;36m[REST API] –í—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è: ${command}\x1b[0m`);
        
        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∫–æ–º–∞–Ω–¥—É –≤ —Ç–µ—Ä–º–∏–Ω–∞–ª
        try {
          ws.send(JSON.stringify({ type: 'data', data: command + '\r' }));
        } catch (e) {
          console.error('[REST Bridge] Failed to send command:', e);
          sendCommandResult('error', '', 'Failed to send command: ' + e.message, null);
        }
      }

      function checkRemoteCommandCompletion() {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –ø–æ—è–≤–∏–ª—Å—è –ª–∏ –Ω–æ–≤—ã–π –ø—Ä–æ–º–ø—Ç (–∫–æ–º–∞–Ω–¥–∞ –∑–∞–≤–µ—Ä—à–∏–ª–∞—Å—å)
        const cleanBuffer = stripAnsiCodes(remoteCommandBuffer);
        
        if (promptRegex.test(cleanBuffer)) {
          // –ö–æ–º–∞–Ω–¥–∞ –∑–∞–≤–µ—Ä—à–∏–ª–∞—Å—å
          console.log('[REST Bridge] Command completed, prompt detected');
          
          // –ò–∑–≤–ª–µ–∫–∞–µ–º –≤—ã–≤–æ–¥ (–±–µ–∑ –ø–æ—Å–ª–µ–¥–Ω–µ–π —Å—Ç—Ä–æ–∫–∏ —Å –ø—Ä–æ–º–ø—Ç–æ–º)
          const lines = cleanBuffer.split('\n');
          let outputLines = [];
          let foundPrompt = false;
          
          for (let i = lines.length - 1; i >= 0; i--) {
            if (promptRegex.test(lines[i])) {
              foundPrompt = true;
              // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —Å—Ç—Ä–æ–∫—É —Å –ø—Ä–æ–º–ø—Ç–æ–º –∏ –≤—Å–µ —á—Ç–æ –ø–æ—Å–ª–µ
              outputLines = lines.slice(0, i);
              break;
            }
          }
          
          // –ü–µ—Ä–≤–∞—è —Å—Ç—Ä–æ–∫–∞ –æ–±—ã—á–Ω–æ —ç—Ö–æ –∫–æ–º–∞–Ω–¥—ã - –ø—Ä–æ–ø—É—Å–∫–∞–µ–º
          if (outputLines.length > 0) {
            outputLines = outputLines.slice(1);
          }
          
          const stdout = outputLines.join('\n').trim();
          
          sendCommandResult('completed', stdout, '', 0);
          
          // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
          remoteCommandCollecting = false;
          remoteCommandBuffer = '';
          pendingRemoteCommand = null;
        }
      }

      function sendCommandResult(status, stdout, stderr, exitCode) {
        if (!pendingRemoteCommand) return;
        
        const result = {
          type: 'command_result',
          commandId: pendingRemoteCommand.commandId,
          status: status,
          stdout: stdout,
          stderr: stderr,
          exitCode: exitCode
        };
        
        console.log('[REST Bridge] Sending result:', result);
        
        try {
          ws.send(JSON.stringify(result));
        } catch (e) {
          console.error('[REST Bridge] Failed to send result:', e);
        }
      }

      function stripAnsiCodes(str) {
        return str.replace(/[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g, '');
      }

      // ========== Command Confirm Button Handlers ==========
      document.getElementById('confirmYes').onclick = () => {
        if (pendingRemoteCommand) {
          hideCommandConfirm();
          executeRemoteCommand(pendingRemoteCommand.command);
        }
      };

      document.getElementById('confirmNo').onclick = () => {
        if (pendingRemoteCommand) {
          term.writeln('\r\n\x1b[1;31m[REST API] –ö–æ–º–∞–Ω–¥–∞ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º\x1b[0m');
          sendCommandResult('rejected', '', 'Command rejected by user', null);
          hideCommandConfirm();
          pendingRemoteCommand = null;
        }
      };

      document.getElementById('confirmSkip').onclick = () => {
        if (pendingRemoteCommand) {
          hideCommandConfirm();
          // –í—ã–ø–æ–ª–Ω—è–µ–º –∏ –∑–∞–ø–æ–º–∏–Ω–∞–µ–º —á—Ç–æ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –Ω–µ –Ω—É–∂–Ω–æ
          executeRemoteCommand(pendingRemoteCommand.command);
        }
      };
    </script>
  </body>
</html>


